--
-- PostgreSQL database dump
--

-- Dumped from database version 17.2
-- Dumped by pg_dump version 17.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: answer; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.answer (
    id integer NOT NULL,
    question_id integer,
    answer_text text NOT NULL,
    is_correct boolean DEFAULT false NOT NULL
);


ALTER TABLE public.answer OWNER TO postgres;

--
-- Name: answer_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.answer ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.answer_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: content_type; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.content_type (
    id integer NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.content_type OWNER TO postgres;

--
-- Name: content_type_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.content_type ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.content_type_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: lesson; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lesson (
    id integer NOT NULL,
    title character varying(255) NOT NULL,
    summary text,
    lesson_order integer
);


ALTER TABLE public.lesson OWNER TO postgres;

--
-- Name: lesson_content; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.lesson_content (
    id integer NOT NULL,
    lesson_id integer,
    content_type_id integer,
    content_data jsonb NOT NULL,
    content_order integer
);


ALTER TABLE public.lesson_content OWNER TO postgres;

--
-- Name: lesson_content_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.lesson_content ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.lesson_content_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: lesson_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.lesson ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.lesson_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: question; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.question (
    id integer NOT NULL,
    lesson_id integer,
    question_text jsonb NOT NULL,
    question_order integer
);


ALTER TABLE public.question OWNER TO postgres;

--
-- Name: question_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.question ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.question_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: role; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.role (
    id integer NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.role OWNER TO postgres;

--
-- Name: role_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.role ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.role_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: user; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public."user" (
    id integer NOT NULL,
    username character varying(50) NOT NULL,
    email text NOT NULL,
    password_hash text NOT NULL,
    first_name text,
    last_name text,
    image_path text,
    role_id integer
);


ALTER TABLE public."user" OWNER TO postgres;

--
-- Name: user_answer; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_answer (
    user_id integer NOT NULL,
    answer_id integer NOT NULL
);


ALTER TABLE public.user_answer OWNER TO postgres;

--
-- Name: user_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public."user" ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.user_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- Name: user_progress; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user_progress (
    user_id integer NOT NULL,
    lesson_id integer NOT NULL,
    is_completed boolean DEFAULT false,
    score numeric(5,2),
    CONSTRAINT user_progress_score_check CHECK (((score >= (0)::numeric) AND (score <= (100)::numeric)))
);


ALTER TABLE public.user_progress OWNER TO postgres;

--
-- Data for Name: answer; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.answer (id, question_id, answer_text, is_correct) FROM stdin;
1	1	A random set of instructions used for art.	f
2	1	A step-by-step procedure to solve a problem.	t
3	1	A software license type.	f
4	2	Graphic design	f
5	2	Biology	f
6	2	Computer Science	t
7	3	It must run forever.	f
8	3	It must have a clear and unambiguous set of instructions.	t
9	3	It must be written in Python.	f
10	4	It should terminate after a finite number of steps.	t
11	4	It should never stop running.	f
12	4	It must return infinite results.	f
13	5	Data Science	t
14	5	Architecture	f
15	5	Geology	f
16	7	The exact number of milliseconds an algorithm takes to run.	f
17	7	The growth of an algorithm’s runtime as input size increases.	t
18	7	The programming language used for the algorithm.	f
19	8	O(1)	t
20	8	O(n)	f
21	8	O(log(n))	f
22	9	The total number of lines in the source code.	f
23	9	The number of inputs or elements the algorithm works with.	t
24	9	The number of errors in the algorithm.	f
25	10	O(n)	f
26	10	O(n^2)	t
27	10	O(1)	f
28	11	O(n log(n))	f
29	11	O(2^n)	t
30	11	O(n)	f
31	12	O(log(n))	t
32	12	O(n)	f
33	12	O(n^2)	f
34	13	It swaps adjacent elements if they are in the wrong order.	f
35	13	It inserts each element into its correct position in the sorted part of the array.	t
36	13	It selects the largest element and moves it to the end.	f
37	14	Bubble Sort	f
38	14	Merge Sort	t
39	14	Insertion Sort	f
40	15	To find the average value of the array	f
41	15	To count the number of swaps.	f
42	15	To divide the array into two parts for recursive sorting.	t
43	16	Insertion Sort	t
44	16	Quick Sort	f
45	16	Selection Sort	f
46	17	Selection Sort	f
47	17	Quick Sort	f
48	17	Merge Sort	t
49	18	Insertion Sort	f
50	18	Selection Sort	t
51	18	Merge Sort	f
52	19	Merging sorted subarrays.	f
53	19	Recursively selecting a pivot.	f
54	19	Swapping adjacent elements repeatedly.	t
55	20	The array must be sorted.	t
56	20	The array must contain only positive numbers.	f
57	20	The array must have unique elements.	f
58	21	By splitting the array in halves.	f
59	21	By checking each element one by one.	t
60	21	By jumping in fixed intervals.	f
61	22	It may return incorrect results.	t
62	22	It still works but slower.	f
63	22	It performs faster.	f
64	23	Linear Search	f
65	23	Binary Search	t
66	24	Linear Search	f
67	24	Binary Search	t
68	25	O(log n)	f
69	25	O(n)	f
70	25	O(1)	t
71	26	A way to program without using objects.	f
72	26	A paradigm that uses classes and objects to design software.	t
73	26	A scripting method for databases.	f
74	27	A blueprint or template for creating objects.	t
75	27	A function that manipulates data.	f
76	27	A variable that stores string values.	f
77	28	A keyword to define a method.	f
78	28	An integer variable.	f
79	28	An instance of a class.	t
80	29	A method to create multiple objects.	f
81	29	Bundling data and methods and restricting access to internal details.	t
82	29	A technique for writing SQL queries.	f
83	30	A mechanism where one class derives from another class.	t
84	30	A function that runs automatically.	f
85	30	A way to delete unused variables.	f
86	31	Hiding complex implementation and exposing only essentials.	t
87	31	A method that multiplies two numbers.	f
88	31	A tool for debugging programs.	f
89	32	Creating objects from text files	f
90	32	Using the same method name with different implementations	t
91	32	Assigning the same value to multiple variables	f
92	33	The Child class does not call the Parent class’s __init__ method, so self.name is never initialized which causes an error when trying to access c.name.	t
93	33	The code fails because the Child class must define a method called name() if it inherits from a class with a name attribute.	f
94	33	The error occurs because you cannot inherit from a class unless both classes have the same __init__ signature.	f
\.


--
-- Data for Name: content_type; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.content_type (id, name) FROM stdin;
1	Text
2	Image
3	Video
4	Code
\.


--
-- Data for Name: lesson; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.lesson (id, title, summary, lesson_order) FROM stdin;
2	Big O Notation	As you begin working with algorithms, it becomes essential to evaluate how efficiently they perform. This lesson introduces a key tool used by computer scientists to describe and compare algorithm performance. With it, we can reason about how programs grow slower or use more memory as the size of the input increases. Learning this concept will help you better understand and design scalable, efficient code for real-world applications.	2
5	OOP	OOP is a fundamental programming paradigm based on the concept of objects — reusable structures that combine data and behavior. This lesson introduces the core principles of OOP: classes and objects, encapsulation, inheritance, polymorphism, and abstraction. You will learn how to design software using these principles, how they support code modularity, and how they enable scalable and maintainable development. Each section focuses on one key idea, with real-world examples and code in multiple languages. Whether you're new to programming or transitioning from procedural thinking, this lesson will give you a solid foundation in how modern software is designed.	5
1	Introduction	This introductory lesson about algorithms sets the foundation for your journey into the world of Computer Science. Before diving into specific techniques or solving problems, it’s important to understand what algorithms are, where they appear in everyday life, and why they are central to the field of computer science. Whether you’re curious about how navigation apps find the fastest route, how websites sort data instantly, or how artificial intelligence makes decisions, it all begins with algorithms. Let’s explore what makes them so powerful and essential.	1
3	Sorting Algos	Sorting algorithms are fundamental tools in CS used to arrange data in a specific order, most commonly from smallest to largest. Efficient sorting improves performance in searching, data analysis, and user interfaces. This lesson introduces a variety of sorting techniques — from basic methods like Bubble Sort, Selection Sort, and Insertion Sort, to more advanced algorithms like Merge Sort and Quick Sort. You will explore how each algorithm works, their strengths and weaknesses, and their time and space complexities. By the end, you will understand not just how to implement each sort, but also how to compare and choose the right algorithm based on the structure and size of your data.	3
4	Search Algos	Searching algorithms allow us to find specific elements within a collection of data. This lesson introduces two of the most fundamental search methods: Linear Search and Binary Search. You’ll learn how each one works, where they are applicable, and how their performance compares. Linear Search is simple and useful for unsorted data, while Binary Search is far more efficient—but only works on sorted collections. By the end of this lesson, you’ll be able to implement both algorithms, understand their time complexities using Big O notation, and know when to choose one over the other depending on the data.	4
\.


--
-- Data for Name: lesson_content; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.lesson_content (id, lesson_id, content_type_id, content_data, content_order) FROM stdin;
16	2	1	{"text": "Big O notation tells you how fast an algorithm is. It is a way to describe how the performance of an algorithm changes as the size of its input increases. It gives you a high-level understanding of how fast or slow your code will run relative to the size of its inputs. In other words, it tells you how much slower a piece of a program gets as the input size gets larger.", "title": "What is Big O notation?"}	1
12	1	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson1/characteristics_of_algo.png"}	6
34	3	1	{"text": "Selection Sort is a simple comparison-based algorithm used to sort elements by repeatedly selecting the smallest (or largest) value from the unsorted portion and moving it to its correct position. It divides the array into two parts: the sorted section on the left and the unsorted section on the right. In each pass, the algorithm scans the unsorted part of the list, finds the minimum value, and swaps it with the first unsorted element. This process continues until the array is fully sorted. Unlike Bubble Sort, which makes many swaps during a pass, Selection Sort minimizes the number of swaps. It is easy to understand and implement, which makes it useful for educational purposes, though it's not suitable for very large datasets.", "title": "What is Selection Sort?"}	7
35	3	4	{"code": "#include <iostream>\\nusing namespace std;\\n\\nvoid selectionSort(int arr[], int n) {\\n    for (int i = 0; i < n - 1; i++) {\\n        int minIndex = i;\\n        for (int j = i + 1; j < n; j++) {\\n            if (arr[j] < arr[minIndex])\\n                minIndex = j;\\n        }\\n        swap(arr[i], arr[minIndex]);\\n    }\\n}\\n\\nint main() {\\n    int data[] = {3, 6, 5, 1, 4};\\n    int size = sizeof(data) / sizeof(data[0]);\\n    selectionSort(data, size);\\n    return 0;\\n}", "output": "1 3 4 5 6", "language": "C++"}	8
36	3	4	{"code": "using System;\\n\\nclass Program {\\n    static void SelectionSort(int[] arr) {\\n        int n = arr.Length;\\n        for (int i = 0; i < n - 1; i++) {\\n            int minIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] < arr[minIndex])\\n                    minIndex = j;\\n            }\\n            (arr[i], arr[minIndex]) = (arr[minIndex], arr[i]);\\n        }\\n    }\\n\\n    static void Main() {\\n        int[] data = { 3, 6, 5, 1, 4 };\\n        SelectionSort(data);\\n    }\\n}", "output": "1 3 4 5 6", "language": "C#"}	9
37	3	4	{"code": "public class Main {\\n    public static void selectionSort(int[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            int minIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] < arr[minIndex])\\n                    minIndex = j;\\n            }\\n            int temp = arr[i];\\n            arr[i] = arr[minIndex];\\n            arr[minIndex] = temp;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] data = {3, 6, 5, 1, 4};\\n        selectionSort(data);\\n    }\\n}", "output": "1 3 4 5 6", "language": "Java"}	10
38	3	4	{"code": "def selection_sort(arr):\\n    n = len(arr)\\n    for i in range(n - 1):\\n        min_index = i\\n        for j in range(i + 1, n):\\n            if arr[j] < arr[min_index]:\\n                min_index = j\\n        arr[i], arr[min_index] = arr[min_index], arr[i]\\n\\ndata = [3, 6, 5, 1, 4]\\nselection_sort(data)", "output": "1 3 4 5 6", "language": "Python"}	11
39	3	1	{"text": "Insertion Sort is a simple and intuitive comparison-based sorting algorithm. It works similarly to how you might sort playing cards in your hands. Starting from the second element, it compares the current item with those before it and swaps it backward until it lands in the correct position. This is repeated for every item until the whole array is sorted. The left portion of the array is always kept sorted, and new elements are inserted into their appropriate place — hence the name Insertion Sort. Although inefficient for large datasets, it performs well on small or nearly-sorted arrays and is useful for learning fundamental algorithmic concepts like nested loops, comparisons, and swapping.", "title": "What is Insertion Sort?"}	12
65	3	1	{"text": "Understanding the strengths and weaknesses of sorting algorithms is crucial for selecting the right tool for the job. Now that you've learned how to organize data efficiently, it's time to explore how to search through it effectively. In the next lesson, we'll dive into Search Algorithms and see how sorting and searching go hand-in-hand."}	38
9	1	1	{"title": "Where Are Algorithms Used?", "bullets": [{"text": "Algorithms are the very foundation upon which software and systems are built. Every action a computer performs — from the moment it boots up to executing a complex program — is driven by algorithms. Sorting algorithms help organize data for fast retrieval, search algorithms help find information efficiently, and hashing algorithms power data structures and databases. Algorithms also play a crucial role in file compression, encryption, networking, compilers, and operating systems. Understanding how and when to apply the right algorithm is key to writing efficient code and building high-performance applications that can scale to real-world demands.", "heading": "Computer Science"}, {"text": "Algorithms provide structured methods to solve equations, process numerical data, and explore abstract problems. Classic examples include Euclid’s algorithm for computing the greatest common divisor, the Newton-Raphson method for finding roots of functions, and the Fast Fourier Transform (FFT) for analyzing signals. These mathematical procedures are not just theoretical; they are essential tools in engineering, physics, statistics, and economics. Algorithms help automate tasks like solving systems of linear equations or optimizing functions. The algorithmic approach ensures repeatability, clarity, and precision, enabling complex problems to be tackled step by step with logic and rigor.", "heading": "Mathematics"}, {"text": "OR is a field that applies algorithms to help organizations make better decisions. In logistics, for example, algorithms calculate the most efficient delivery routes to save time and fuel. In manufacturing, they determine optimal production schedules to reduce waste and costs. OR uses methods like linear programming, integer optimization, and network flow algorithms to solve problems in resource allocation, facility layout, and supply chain management. These algorithms help balance constraints and objectives in real-world environments, where resources are limited and choices have trade-offs. As businesses grow in complexity, algorithmic decision-making becomes not only helpful but essential.", "heading": "Operations Research"}, {"text": "AI would not exist without algorithms. At its core, AI is a collection of algorithms that allow machines to mimic cognitive functions such as learning, reasoning, and problem-solving. Machine learning, a subset of AI, uses algorithms to detect patterns in data and make predictions or decisions without being explicitly programmed for each task. For example, recommendation systems on Netflix or YouTube use collaborative filtering algorithms, while neural networks power image recognition and speech-to-text systems. Reinforcement learning algorithms allow agents to learn from interaction with an environment. Algorithms are what enable AI to adapt, improve, and perform complex tasks autonomously.", "heading": "Artificial Intelligence"}, {"text": "DS relies on algorithms to extract meaning and value from massive amounts of data. Algorithms are used for tasks like data cleaning, feature selection, classification, clustering, regression, and visualization. In marketing, algorithms segment customers and predict buying behavior; in healthcare, they help detect diseases from medical images or patient records. Financial institutions use algorithms for fraud detection and risk assessment. Without algorithms, raw data is just noise. With them, we can uncover hidden trends, build predictive models, and make informed decisions. Data science combines domain knowledge, statistical methods, and algorithmic techniques to generate real-world impact from information.", "heading": "Data Science"}]}	4
1	1	1	{"text": "An algorithm is a set of instructions for accomplishing a task. One can say that it is a sequence of finite steps that transform an input into an output. It is a tool for solving well-specified computational problems. Algorithms can be simple and complex depending on what you want to achieve. They are necessary for solving complex problems efficiently and effectively because they help to automate processes and make them more reliable, faster, and easier to perform. Algorithms also enable computers to perform tasks that would be difficult or impossible for humans to do manually.", "title": "What is an Algorithm?"}	2
2	1	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson1/what_is_algo%20(1).png"}	3
33	3	4	{"code": "def bubble_sort(arr):\\n    n = len(arr)\\n    for i in range(n - 1):\\n        swapped = False\\n        for j in range(n - i - 1):\\n            if arr[j] > arr[j + 1]:\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n                swapped = True\\n        if not swapped:\\n            break\\n\\ndata = [3, 6, 5, 1, 4]\\nbubble_sort(data)", "output": "1 3 4 5 6", "language": "Python"}	6
17	2	1	{"text": "In algorithm analysis, we often ask: how long does this operation take, and how does that time grow as the input gets larger? To answer that, we use Big O notation. When analyzing linear search, we examine its performance in different scenarios — called best case, worst case, and average case. These cases describe how many steps the algorithm takes depending on where the searched value appears in the list. Big O helps us express these behaviors in a language that's independent of the machine running the code. It focuses on how performance scales, not on exact timing. Before we dive into the time complexities, it’s important to understand what n means. In this context, n is the number of items in the list or array you're searching through. The more elements, the longer the search might take — depending on the location of the target value.", "title": "Example - Linear Search", "bullets": [{"text": "This happens when the value you're searching for is the very first element in the list. The algorithm finds it immediately and exits after just one comparison. The operation runs in constant time because it takes the same number of steps no matter how large the input is. For example, it doesn’t matter whether the array has 10 or 10 million items, the operation is always one step.", "heading": "Best Case — O(1)"}, {"text": "Occurs when the target value is either at the very end of the list or not in the list at all. The algorithm must check every single element before it can return a result. It runs in linear time because the number of steps increases proportionally with the input size. In linear search, the algorithm examines each element one at a time from start to finish. The more elements there are, the longer it takes. If the list is twice as long, the search may take twice as many steps.", "heading": "Worst Case — O(n)"}, {"text": "On average, the value is somewhere in the middle of the list. You might think this means it takes half as long — and you're right. But in Big O notation we drop constants, so O(n/2) becomes O(n). This is why both average and worst case are considered O(n).", "heading": "Average Case — O(n)"}]}	2
22	2	1	{"text": "This chart shows how different algorithm time complexities grow as the size of the input data (n) increases. The horizontal axis (x-axis) represents the number of elements being processed, while the vertical axis (y-axis) shows the number of operations an algorithm needs to perform. Each curve represents a common time complexity expressed in Big O notation. The colors help visualize performance: green zones (O(1), O(log n)) indicate excellent performance and scalability, while red zones (O(n^2), O(2^n), O(n!)) highlight algorithms that become impractical as data size grows. Yellow and orange zones (O(n), O(n log n)) are generally acceptable in many real-world scenarios but can still become costly with very large inputs. The key takeaway is that as n increases, the gap between efficient and inefficient algorithms widens dramatically. Big O notation helps us reason about this growth and choose the most suitable algorithm for a given problem.", "title": "Understanding the Big O Chart"}	7
23	2	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson2/BigO_Complexity.png"}	8
24	1	1	{"text": "Now that you understand what algorithms are and where they’re used, it’s time to take the next step. In the next lesson, we’ll introduce Big O Notation — a powerful way to measure how efficient an algorithm is as input size grows. This will help you evaluate the performance of your code and make smarter choices when solving problems."}	11
25	2	1	{"text": "Now that you’ve learned how to measure algorithm performance using Big O Notation, it’s time to see it in action. In the next lesson, we’ll explore all sorts of sorting algorithms. You’ll learn how they work and what their time complexities look like."}	9
40	3	4	{"code": "#include <iostream>\\nusing namespace std;\\n\\nvoid insertionSort(int data[], int n) {\\n    for (int i = 1; i < n; i++) {\\n        int j = i;\\n        while (j > 0 && data[j - 1] > data[j]) {\\n            swap(data[j], data[j - 1]);\\n            j--;\\n        }\\n    }\\n}\\n\\nint main() {\\n    int data[] = {6, 3, 5, 1, 4};\\n    int size = sizeof(data) / sizeof(data[0]);\\n    insertionSort(data, size);\\n    return 0;\\n}", "output": "1 3 4 5 6", "language": "C++"}	13
28	3	1	{"text": "Sorting is the process of arranging elements in a specific order, typically ascending or descending. Whether it's numbers, words, or objects, sorting makes data easier to search, analyze, and use. For example, sorted data enables faster search algorithms, improves the efficiency of databases, and enhances user experience in applications. Without sorting, structured data processing would be significantly slower and more error-prone.", "title": "What Is Sorting?"}	1
29	3	1	{"text": "Bubble Sort is a simple comparison-based sorting algorithm. It works by repeatedly stepping through the list and comparing each pair of adjacent elements. If a pair is in the wrong order, the algorithm swaps them. This way, larger values bubble up toward the end of the array with each pass. After each full pass through the array, the next largest element is in its correct position. The process continues until the entire list is sorted. To optimize performance, Bubble Sort often includes a flag to track whether any swaps were made during a pass. If no swaps occur, the list is already sorted and the algorithm stops early using the break keyword. The algorithm uses two nested loops: the inner loop performs comparisons and swaps; the outer loop handles how many times the process repeats. If the break is triggered, the outer loop exits immediately, avoiding unnecessary work. While Bubble Sort is not the most efficient algorithm for large datasets, it is one of the easiest to understand and implement, making it ideal for learning how sorting algorithms work.", "title": "What is Bubble Sort?"}	2
30	3	4	{"code": "#include <iostream>\\nusing namespace std;\\n\\nvoid bubbleSort(int arr[], int n) {\\n    for (int i = 0; i < n - 1; i++) {\\n        bool swapped = false;\\n        for (int j = 0; j < n - i - 1; j++) {\\n            if (arr[j] > arr[j + 1]) {\\n                swap(arr[j], arr[j + 1]);\\n                swapped = true;\\n            }\\n        }\\n        if (!swapped) break;\\n    }\\n}\\n\\nint main() {\\n    int data[] = {3, 6, 5, 1, 4};\\n    int size = sizeof(data) / sizeof(data[0]);\\n    bubbleSort(data, size);\\n    for (int i = 0; i < size; i++) cout << data[i] << \\" \\";\\n    return 0;\\n}", "output": "1 3 4 5 6", "language": "C++"}	3
31	3	4	{"code": "using System;\\n\\nclass Program {\\n    static void BubbleSort(int[] arr) {\\n        int n = arr.Length;\\n        for (int i = 0; i < n - 1; i++) {\\n            bool swapped = false;\\n            for (int j = 0; j < n - i - 1; j++) {\\n                if (arr[j] > arr[j + 1]) {\\n                    (arr[j], arr[j + 1]) = (arr[j + 1], arr[j]);\\n                    swapped = true;\\n                }\\n            }\\n            if (!swapped) break;\\n        }\\n    }\\n    static void Main() {\\n        int[] data = { 3, 6, 5, 1, 4 };\\n        BubbleSort(data);\\n    }\\n}", "output": "1 3 4 5 6", "language": "C#"}	4
32	3	4	{"code": "public class Main {\\n    public static void bubbleSort(int[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) {\\n            boolean swapped = false;\\n            for (int j = 0; j < n - i - 1; j++) {\\n                if (arr[j] > arr[j + 1]) {\\n                    int temp = arr[j];\\n                    arr[j] = arr[j + 1];\\n                    arr[j + 1] = temp;\\n                    swapped = true;\\n                }\\n            }\\n            if (!swapped) break;\\n        }\\n    }\\n    public static void main(String[] args) {\\n        int[] data = {3, 6, 5, 1, 4};\\n        bubbleSort(data);\\n    }\\n}", "output": "1 3 4 5 6", "language": "Java"}	5
44	3	1	{"text": "Merge Sort is a classic divide-and-conquer sorting algorithm. It works by breaking the input array into two halves, sorting them recursively, and then merging them back together in a sorted manner. Unlike simpler algorithms, Merge Sort guarantees O(n log n) time complexity in all cases—best, average, and worst. It is efficient and stable, but requires additional space to store temporary arrays during merging. Despite the extra space usage, it performs well on large datasets and is a go-to sorting technique in many high-performance applications.", "title": "What is Merge Sort?"}	17
45	3	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson3/merge_sort_example.png"}	18
46	3	1	{"text": "The diagram shows how Merge Sort splits the array recursively into subarrays of length 1 and then merges them back in sorted order. For example, the array [38, 27, 43, 3, 9, 82, 10] is split into [38, 27, 43, 3] and [9, 82, 10]. Each half is split again until we have single-element arrays. These are then merged step-by-step in sorted order: [27, 38], [3, 43], etc., and finally we get [3, 9, 10, 27, 38, 43, 82]. This visual helps grasp the recursive and merging nature of the Merge Sort clearly."}	19
47	3	4	{"code": "#include <iostream>\\nusing namespace std;\\n\\nvoid merge(int arr[], int left, int mid, int right) {\\n    int n1 = mid - left + 1;\\n    int n2 = right - mid;\\n\\n    int L[100], R[100];\\n\\n    for (int i = 0; i < n1; i++) {\\n        L[i] = arr[left + i];\\n    }\\n    for (int j = 0; j < n2; j++) {\\n        R[j] = arr[mid + 1 + j];\\n    }\\n\\n    int i = 0, j = 0, k = left;\\n\\n    while (i < n1 && j < n2) {\\n        if (L[i] <= R[j]) {\\n            arr[k++] = L[i++];\\n        } else {\\n            arr[k++] = R[j++];\\n        }\\n    }\\n\\n    while (i < n1) {\\n        arr[k++] = L[i++];\\n    }\\n\\n    while (j < n2) {\\n        arr[k++] = R[j++];\\n    }\\n}\\n\\nvoid mergeSort(int arr[], int left, int right) {\\n    if (left < right) {\\n        int mid = (left + right) / 2;\\n\\n        mergeSort(arr, left, mid);\\n        mergeSort(arr, mid + 1, right);\\n\\n        merge(arr, left, mid, right);\\n    }\\n}\\n\\nint main() {\\n    int arr[] = { 38, 27, 43, 3, 9, 82, 10 };\\n    int size = sizeof(arr) / sizeof(arr[0]);\\n\\n    mergeSort(arr, 0, size - 1);\\n\\n    return 0;\\n}", "output": "3 9 10 27 38 43 82", "language": "C++"}	20
48	3	4	{"code": "using System;\\n\\nclass Program {\\n    static void Merge(int[] arr, int left, int mid, int right) {\\n        int n1 = mid - left + 1;\\n        int n2 = right - mid;\\n\\n        int[] L = new int[n1];\\n        int[] R = new int[n2];\\n\\n        for (int i = 0; i < n1; i++) {\\n            L[i] = arr[left + i];\\n        }\\n        for (int j = 0; j < n2; j++) {\\n            R[j] = arr[mid + 1 + j];\\n        }\\n\\n        int k = left, i1 = 0, j1 = 0;\\n        while (i1 < n1 && j1 < n2) {\\n            if (L[i1] <= R[j1]) {\\n                arr[k++] = L[i1++];\\n            } else {\\n                arr[k++] = R[j1++];\\n            }\\n        }\\n        while (i1 < n1) {\\n            arr[k++] = L[i1++];\\n        }\\n        while (j1 < n2) {\\n            arr[k++] = R[j1++];\\n        }\\n    }\\n\\n    static void MergeSort(int[] arr, int left, int right) {\\n        if (left < right) {\\n            int mid = (left + right) / 2;\\n            MergeSort(arr, left, mid);\\n            MergeSort(arr, mid + 1, right);\\n            Merge(arr, left, mid, right);\\n        }\\n    }\\n\\n    static void Main() {\\n        int[] arr = { 38, 27, 43, 3, 9, 82, 10 };\\n        MergeSort(arr, 0, arr.Length - 1);\\n    }\\n}", "output": "3 9 10 27 38 43 82", "language": "C#"}	21
49	3	4	{"code": "public class Main {\\n    public static void merge(int[] arr, int left, int mid, int right) {\\n        int n1 = mid - left + 1;\\n        int n2 = right - mid;\\n\\n        int[] L = new int[n1];\\n        int[] R = new int[n2];\\n\\n        for (int i = 0; i < n1; i++) {\\n            L[i] = arr[left + i];\\n        }\\n        for (int j = 0; j < n2; j++) {\\n            R[j] = arr[mid + 1 + j];\\n        }\\n\\n        int i = 0, j = 0, k = left;\\n\\n        while (i < n1 && j < n2) {\\n            if (L[i] <= R[j]) {\\n                arr[k++] = L[i++];\\n            } else {\\n                arr[k++] = R[j++];\\n            }\\n        }\\n        while (i < n1) {\\n            arr[k++] = L[i++];\\n        }\\n        while (j < n2) {\\n            arr[k++] = R[j++];\\n        }\\n    }\\n\\n    public static void mergeSort(int[] arr, int left, int right) {\\n        if (left < right) {\\n            int mid = (left + right) / 2;\\n            mergeSort(arr, left, mid);\\n            mergeSort(arr, mid + 1, right);\\n            merge(arr, left, mid, right);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = { 38, 27, 43, 3, 9, 82, 10 };\\n        mergeSort(arr, 0, arr.length - 1);\\n    }\\n}", "output": "3 9 10 27 38 43 82", "language": "Java"}	22
50	3	4	{"code": "def merge(arr, left, mid, right):\\n    L = arr[left:mid+1]\\n    R = arr[mid+1:right+1]\\n\\n    i = j = 0\\n    k = left\\n\\n    while i < len(L) and j < len(R):\\n        if L[i] <= R[j]:\\n            arr[k] = L[i]\\n            i += 1\\n        else:\\n            arr[k] = R[j]\\n            j += 1\\n        k += 1\\n\\n    while i < len(L):\\n        arr[k] = L[i]\\n        i += 1\\n        k += 1\\n\\n    while j < len(R):\\n        arr[k] = R[j]\\n        j += 1\\n        k += 1\\n\\ndef merge_sort(arr, left, right):\\n    if left < right:\\n        mid = (left + right) // 2\\n        merge_sort(arr, left, mid)\\n        merge_sort(arr, mid + 1, right)\\n        merge(arr, left, mid, right)\\n\\narr = [38, 27, 43, 3, 9, 82, 10]\\nmerge_sort(arr, 0, len(arr) - 1)", "output": "3 9 10 27 38 43 82", "language": "Python"}	23
64	3	1	{"text": "Quick Sort is often the fastest sorting algorithm in practice. It has an average-case complexity of Θ(n log n) but can degrade to O(n²) if the pivot elements are poorly chosen. It partitions the array around a pivot and recursively sorts the partitions. It is in-place and very efficient, widely used in performance-critical systems and libraries."}	37
43	3	4	{"code": "def insertion_sort(data):\\n    for i in range(1, len(data)):\\n        j = i\\n        while j > 0 and data[j - 1] > data[j]:\\n            data[j], data[j - 1] = data[j - 1], data[j]\\n            j -= 1\\n\\ndata = [6, 3, 5, 1, 4]\\ninsertion_sort(data)", "output": "1 3 4 5 6", "language": "Python"}	16
51	3	1	{"text": "Quick Sort is a highly efficient sorting algorithm that uses the divide-and-conquer strategy. The core concept revolves around selecting a pivot element from the array and partitioning the other elements into two subarrays: those less than or equal to the pivot and those greater than the pivot. The process is recursively repeated for each subarray until all elements are sorted. The pivot acts as a separator that splits the array into smaller, manageable parts. It does not need to be the median — often the last or first element is chosen for simplicity. The key steps in Quick Sort are: pick a pivot, rearrange the array so all elements less than the pivot are on the left and all greater are on the right and then apply Quick Sort on the left and right subarrays. We are excluding the pivot, which is now in the correct position. This recursive partitioning continues until subarrays of size 0 or 1 are reached, which are naturally sorted. Quick Sort is popular because of its good average-case time complexity of O(n log n), and it's often faster in practice than other O(n log n) algorithms like Merge Sort due to lower overhead and better cache performance. ", "title": "What is Quick Sort?"}	24
52	3	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson3/quick_sort.png"}	25
53	3	1	{"text": "The diagram shows how Quick Sort partitions an array using the first element as the pivot. The initial array is [38, 27, 43, 3, 9, 82, 10], with 38 selected as the pivot. Two pointers are used: pointer i starts from the left and moves right, looking for elements greater than the pivot; pointer j starts from the right and moves left, looking for elements smaller than the pivot. When i and j both stop, their values are swapped. This continues until i and j cross. Finally, the pivot is swapped with the value at pointer j, placing it in its correct sorted position. This divides the array into two subarrays: elements less than the pivot to the left and elements greater than the pivot to the right. The process then recurses on both halves. The diagram visualizes a single partitioning step where 38 is the pivot, and the array gets rearranged to [9, 27, 10, 3, 38, 82, 43], followed by two recursive quick sort calls."}	26
58	3	1	{"text": "Now we'll show a diagram that compares five sorting algorithms that we have mentioned above: Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, and Quick Sort based on their time complexity. Each algorithm behaves differently depending on the input, and the table highlights how they perform in the best, average, and worst-case scenarios. Understanding this will help you choose the most suitable algorithm for a particular problem.", "title": "Understanding Big O Notation in Sorting Algorithms"}	31
59	3	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson3/sort_algos_time_complexity.png"}	32
60	3	1	{"text": "Bubble Sort is one of the simplest sorting algorithms. It has a best-case time complexity of O(n) when the list is already sorted, but its average and worst-case complexities are both Θ(n^2). Bubble Sort works by repeatedly swapping adjacent elements if they are in the wrong order. Due to its inefficiency on large datasets, it is mainly used for educational purposes or small collections of data."}	33
61	3	1	{"text": "Selection Sort always performs O(n^2) comparisons regardless of the input's initial order. It works by selecting the minimum element from the unsorted part and placing it at the beginning. Its simplicity and low memory usage make it useful in environments where memory writes are more expensive than reads, but it is not efficient for large lists."}	34
62	3	1	{"text": "Insertion Sort performs efficiently on small or nearly sorted data. It has a best-case complexity of O(n) and worst-case complexity of O(n^2). This algorithm builds the sorted array one element at a time, inserting elements into their correct position. It is in-place and stable, making it a good choice for small or adaptive sorting tasks."}	35
63	3	1	{"text": "Merge Sort consistently operates in O(n log(n)) time in all cases, making it reliable for predictable performance. It uses the divide-and-conquer approach, recursively breaking down the array and merging sorted subarrays. It is stable and works well on large datasets."}	36
66	4	1	{"text": "Searching is the process of finding the presence or position of a specific element within a collection of data. This task is fundamental to computing and is used everywhere—from checking your inbox for a specific email, to retrieving a user record in a database, to locating a file on your device. The efficiency of a search directly affects how fast applications can respond and how smoothly systems run. In small datasets, a basic method may be enough, but as data grows, smarter algorithms are required. That is why searching is one of the core topics in CS. In this lesson, we will examine two essential search algorithms. The first is Linear Search, which is the simplest method and works well for small or unsorted data. The second is Binary Search, which is much faster but only works when data is already sorted. We will study how both algorithms work, where they should be used, and how their time complexities compare using Big O notation.", "title": "What Is Searching?"}	1
69	4	4	{"code": "using System;\\n\\nclass Program {\\n    static int LinearSearch(int[] arr, int target) {\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (arr[i] == target) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    static void Main() {\\n        int[] data = { 4, 2, 7, 1, 9 };\\n        Console.WriteLine(\\"Found at index: \\" + LinearSearch(data, 1));\\n    }\\n}", "output": "Found at index: 3", "language": "C#"}	4
70	4	4	{"code": "public class Main {\\n    public static int linearSearch(int[] arr, int target) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == target) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] data = {4, 2, 7, 1, 9};\\n        System.out.println(\\"Found at index: \\" + linearSearch(data, 1));\\n    }\\n}", "output": "Found at index: 3", "language": "Java"}	5
67	4	1	{"text": "Linear or Sequential Search is the most basic search algorithm. It works by checking each element in a collection one by one until the desired value is found or the list ends. Because it doesn't require the data to be sorted, it is useful for small or unsorted datasets. For example, if you're looking for a specific name in a guest list that is not ordered, a linear search will simply go down the list until it finds a match. Although it is simple to implement and understand, it becomes inefficient as the size of the data increases, since it may need to check every single item.", "title": "What Is Linear Search?"}	2
72	4	1	{"text": "Binary Search is a highly efficient algorithm used to find the position of a target value within a sorted array. Unlike Linear Search, which checks every element one by one, Binary Search repeatedly divides the search space in half. It starts by comparing the target with the middle element: if the target equals the middle, it returns the index. If the target is less than the middle value, the search continues on the left half; if it's greater, the right half is searched. This divide-and-conquer strategy significantly reduces the number of comparisons needed. However, Binary Search only works on sorted arrays. It's widely used in scenarios requiring fast lookups, such as searching in databases, dictionaries, or large datasets already sorted in order.", "title": "What is Binary Search?"}	7
68	4	4	{"code": "#include <iostream>\\\\nusing namespace std;\\n\\nint linearSearch(int arr[], int size, int target) {\\n    for (int i = 0; i < size; i++) {\\n        if (arr[i] == target) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint main() {\\n    int data[] = { 4, 2, 7, 1, 9 };\\n    int size = sizeof(data) / sizeof(data[0]);\\n\\n    cout << \\"Found at index: \\" << linearSearch(data, size, 1) << endl;\\n\\n    return 0;\\n}", "output": "Found at index: 3", "language": "C++"}	3
71	4	4	{"code": "def linear_search(arr, target):\\n    for i in range(len(arr)):\\n        if arr[i] == target:\\n            return i\\n    return -1\\n\\ndata = [4, 2, 7, 1, 9]\\nprint(\\"Found at index: \\", linear_search(data, 1))", "output": "Found at index: 3", "language": "Python"}	6
73	4	4	{"code": "#include <iostream>\\nusing namespace std;\\n\\nint binarySearch(int arr[], int size, int target) {\\n    int left = 0;\\n    int right = size - 1;\\n\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n\\n        if (arr[mid] == target) {\\n            return mid;\\n        } else if (arr[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n\\nint main() {\\n    int data[] = { 1, 2, 4, 7, 9 };\\n    int size = sizeof(data) / sizeof(data[0]);\\n\\n    cout << \\"Found at index: \\" << binarySearch(data, size, 7) << endl;\\n    return 0;\\n}", "output": "Found at index: 3", "language": "C++"}	8
77	4	1	{"text": "In this lesson, we explored two of the most fundamental search techniques: Linear Search and Binary Search. You learned how Linear Search is straightforward and effective for unsorted data, while Binary Search is much faster, but only works on sorted collections. Understanding how and when to use these search algorithms is essential for writing efficient code. In the next lesson, we’ll shift our focus from algorithms to a major programming paradigm i.e. Object-Oriented Programming. There, you’ll discover how to model real-world systems using objects, classes, inheritance, polymorphism, and encapsulation."}	14
78	4	1	{"text": "Understanding the time complexities of search algorithms is crucial to knowing when and where to use them. The following table compares the best, average, and worst-case time complexities of both algorithms. As shown in the table, Linear Search has a best-case time complexity of O(1), which occurs when the target is the first element. However, in the average and worst-case scenarios, it has to check each element until it finds the target or reaches the end, resulting in O(n) time. In contrast, Binary Search also has a best-case of O(1) if the target is the middle element, but it maintains a much better O(log(n)) time complexity on average and in the worst case, because it halves the search space each time. ", "title": "Understanding Big O Notation in Searching Algorithms"}	12
79	4	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson4/bigO_search_algo.png"}	13
80	5	1	{"text": "Object-Oriented Programming (OOP) is a programming paradigm that uses objects and classes to design and develop software applications. It is based on the concept of objects, which can contain data in the form of fields and code in the form of methods. OOP offers several benefits, including: modularity by breaking down complex systems into smaller, manageable parts, reusability by reusing existing code by creating new objects based on existing ones, flexibility is provided when designing and implementing software systems because you can easily modify and extend the functionality of objects without affecting other parts of the system and scalability allowing to add new objects and classes as the system grows which makes it easier to accommodate changes and enhancements in the software. As you can see, OOP offers several advantages that makes it a popular choice for developing software applications.", "title": "What is OOP?"}	1
81	5	1	{"text": "Class is a template of what an object will be, but it is not the object itself. It is a user-defined data type, that holds its own data members and member functions, which can be accessed and used by creating an instance of that class. Once we have written a class and defined it, we can use it to create as many objects based on that class as we want. A class contains fields, constructors, and methods. For example, consider the Class of Car. Car can be Ford, Toyota or a Volkswagen which will represent objects, and all of them will share some common properties, like tires, needing fuel, engine, brakes etc. Object is an instance of a class like we have shown in our example. All data members and member functions of the class can be accessed with the help of objects. When a class is defined, no memory is allocated, but memory is allocated when it is instantiated i.e. when the object is created.", "title": "What are classes and objects?"}	2
82	5	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson5/class_vs_object_example.png"}	3
83	5	1	{"text": "OOP is built around four foundational principles that guide how we design and organize software: Encapsulation, Inheritance, Abstraction, and Polymorphism. These pillars are essential in building modular, maintainable, and reusable code. In this section, we’ll explore each of these pillars individually and learn how they help model real-world behavior in code.", "title": "The Four Pillars of OOP"}	4
85	5	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson5/encapsulation.png"}	6
84	5	1	{"text": "Encapsulation is the concept of bundling fields and the methods that operate on that data into a single unit, typically a class. It restricts direct access to internal object details and ensures that changes to data happen in a controlled manner. For example, a BankAccount class may expose a Deposit() and Withdraw() method, but keep the balance field private. This allows validation and protection of critical information. Encapsulation enhances security, simplifies debugging, and allows internal changes without affecting other parts of a program. The balance field is private – it can’t be accessed or modified directly from outside the class. The class provides controlled access through Deposit(), Withdraw(), and GetBalance() methods. This hides the internal implementation while exposing a safe public interface.", "title": "Encapsulation"}	5
86	5	1	{"text": "Inheritance allows one class to acquire properties and behaviors from another class. The class that inherits is called a subclass or derived class, and the class it inherits from is called a superclass or base class. For example, a Car class can inherit from a general Vehicle class and automatically gain its methods like start() or stop(), while adding specific features like playMusic(). Inheritance promotes code reuse, consistency, and the creation of hierarchies, which is useful when multiple classes share common features.", "title": "Inheritance"}	7
87	5	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson5/inheritance.png"}	8
88	5	1	{"text": "Abstraction is the process of hiding complex implementation details and showing only the essential features of an object. For example, RemoteControl is an abstract class with no implementation — just method declarations for TurnOn() and TurnOff(). TVRemote is a concrete class that provides the actual logic for those methods. Abstraction reduces system complexity, helps manage large codebases, and allows developers to focus on interactions rather than internal logic. It’s typically achieved through abstract classes and interfaces.", "title": "Abstraction"}	9
89	5	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson5/abstraction.png"}	10
90	5	1	{"text": "Polymorphism enables one interface to be used for many implementations. This means the same method name can behave differently depending on the object. For instance, a draw() method might act differently for a Circle, Rectangle, or Triangle class, even though it shares the same name. Polymorphism is a powerful feature in OOP that increases flexibility and code maintainability. ", "title": "Polymorphism"}	11
91	5	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson5/polymorphism.png"}	12
92	5	1	{"text": "This is the last lesson on this learning platform. In this lesson we learned about OOP which helps developers model real-world systems more naturally. Whether you're designing a simple application or building large-scale enterprise systems, understanding and applying these principles allows you to write cleaner, more efficient, and more adaptable code. Mastering OOP is an essential step toward becoming a proficient software developer."}	13
41	3	4	{"code": "using System;\\nclass Program {\\n    static void InsertionSort(int[] data) {\\n        for (int i = 1; i < data.Length; i++) {\\n            int j = i;\\n            while (j > 0 && data[j - 1] > data[j]) {\\n                (data[j], data[j - 1]) = (data[j - 1], data[j]);\\n                j--;\\n            }\\n        }\\n    }\\n    static void Main() {\\n        int[] data = { 6, 3, 5, 1, 4 };\\n        InsertionSort(data);\\n    }\\n}", "output": "1 3 4 5 6", "language": "C#"}	14
42	3	4	{"code": "public class Main {\\n    public static void insertionSort(int[] data) {\\n        for (int i = 1; i < data.length; i++) {\\n            int j = i;\\n            while (j > 0 && data[j - 1] > data[j]) {\\n                int temp = data[j];\\n                data[j] = data[j - 1];\\n                data[j - 1] = temp;\\n                j--;\\n            }\\n        }\\n    }\\n    public static void main(String[] args) {\\n        int[] data = {6, 3, 5, 1, 4};\\n        insertionSort(data);\\n    }\\n}", "output": "1 3 4 5 6", "language": "Java"}	15
74	4	4	{"code": "using System;\\n\\nclass Program {\\n    static int BinarySearch(int[] arr, int target) {\\n        int left = 0;\\n        int right = arr.Length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    static void Main() {\\n        int[] data = { 1, 2, 4, 7, 9 };\\n        Console.WriteLine(\\"Found at index: \\" + BinarySearch(data, 7));\\n    }\\n}", "output": "Found at index: 3", "language": "C#"}	9
15	1	1	{"answer": "He read the instructions on the shampoo bottle: \\\\n<i><b><center>Massage into wet hair. Lather. Rinse. Repeat.</center></b></i>", "question": "Why did the programmer go into the shower to wash his hair and never come out?"}	1
13	1	1	{"text": "This recipe represents a real-life example of an algorithm. Like any algorithm, it includes a clearly defined set of inputs, a specific output, and a structured sequence of steps that must be followed in order. It also contains a loop that continues until a condition is met — in this case, until the batter is used up. The example illustrates how everyday tasks like cooking can be broken down into algorithmic logic. By identifying elements such as input, output, conditionals, and repetition, learners can begin to relate algorithmic thinking to practical, real-world scenarios.", "title": "Example of an algorithm - Pancakes"}	7
93	1	2	{"image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson1/recipe.png"}	8
14	1	3	{"url": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson1/algo_intro.mp4"}	10
94	1	1	{"text": "In the following video, we wrap up everything you’ve learned in this introductory lesson on algorithms. We start by revisiting the fundamental definition of the algorithm, we saw how algorithms are used not only in CS, but also in mathematics, operations research, artificial intelligence, and data science. We have also shown a real-world example of an algorithm, like a pancake recipe and we have covered essential characteristics that make an algorithm effective. These principles ensure algorithms are understandable, executable, and universally applicable. The goal of this lesson was to build your intuition about what algorithms are and why they matter.This video ties it all together visually, giving you a cohesive summary of key points and preparing you for more advanced topics ahead. Watch carefully, take notes, and reflect on how these principles appear in the technology you use every day."}	9
11	1	1	{"title": "Characteristics of an Algorithm", "bullets": [{"text": "The algorithm should be unambiguous. Each of its steps must be stated precisely and must lead to a single, clear outcome without any room for interpretation. Ambiguity in instructions can result in errors or inconsistent results. For example, instead of saying <i>process the data</i>, it should specify how to process it — such as <i>sort the data in ascending order using quicksort</i>.", "heading": "Clear and unambiguous"}, {"text": "An algorithm must produce at least one output that is both consistent and clearly defined. This output should be directly related to the provided input and the problem the algorithm is solving. A clear output ensures that the result of running the algorithm can be evaluated and used. For example, a sorting algorithm's output must be a list sorted according to specified criteria, such as numerical or alphabetical order.", "heading": "Well-defined outputs"}, {"text": "Every algorithm must terminate after a finite number of steps. This means it cannot run indefinitely or rely on infinite loops. Finiteness ensures that the algorithm eventually provides a result. For example, a loop that continues until a condition is met must guarantee that the condition can be reached; otherwise, the algorithm becomes non-functional.", "heading": "Finiteness"}, {"text": "The steps of an algorithm must be realistically executable with the available resources and within a reasonable time frame. This includes considerations like processing power, memory, and implementation tools. An algorithm that assumes capabilities beyond what's currently possible is not feasible. For instance, it should not include steps like 'predict user behavior perfectly' unless a concrete method exists for doing so.", "heading": "Feasibility"}, {"text": "An algorithm should be written in a manner that is not tied to a specific programming language. It should consist of logical instructions that can be implemented in any language. This makes the algorithm versatile and accessible to developers working with different technologies. For example, a pseudocode representation of an algorithm helps describe the logic clearly, regardless of the actual language used for implementation.", "heading": "Language independent"}]}	5
54	3	4	{"code": "#include <iostream>\\nusing namespace std;\\n\\nint partition(int arr[], int low, int high) {\\n    int pivot = arr[high];\\n    int i = low - 1;\\n\\n    for (int j = low; j < high; j++) {\\n        if (arr[j] < pivot) {\\n            i++;\\n            swap(arr[i], arr[j]);\\n        }\\n    }\\n\\n    swap(arr[i + 1], arr[high]);\\n    return i + 1;\\n}\\n\\nvoid quickSort(int arr[], int low, int high) {\\n    if (low < high) {\\n        int pi = partition(arr, low, high);\\n        quickSort(arr, low, pi - 1);\\n        quickSort(arr, pi + 1, high);\\n    }\\n}\\n\\nint main() {\\n    int arr[] = { 38, 27, 43, 3, 9, 82, 10 };\\n    int size = sizeof(arr) / sizeof(arr[0]);\\n    quickSort(arr, 0, size - 1);\\n    return 0;\\n}", "output": "3 9 10 27 38 43 82", "language": "C++"}	27
55	3	4	{"code": "using System;\\nclass Program {\\n    static int Partition(int[] arr, int low, int high) {\\n        int pivot = arr[high];\\n        int i = low - 1;\\n        for (int j = low; j < high; j++) {\\n            if (arr[j] < pivot) {\\\\n                i++;\\n                (arr[i], arr[j]) = (arr[j], arr[i]);\\n            }\\n        }\\n        (arr[i + 1], arr[high]) = (arr[high], arr[i + 1]);\\n        return i + 1;\\n    }\\n    static void QuickSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int pi = Partition(arr, low, high);\\n            QuickSort(arr, low, pi - 1);\\n            QuickSort(arr, pi + 1, high);\\n        }\\n    }\\n    static void Main() {\\n        int[] arr = { 38, 27, 43, 3, 9, 82, 10 };\\n        QuickSort(arr, 0, arr.Length - 1);\\n    }\\n}", "output": "3 9 10 27 38 43 82", "language": "C#"}	28
56	3	4	{"code": "public class Main {\\n    public static int partition(int[] arr, int low, int high) {\\n        int pivot = arr[high];\\n        int i = low - 1;\\n        for (int j = low; j < high; j++) {\\n            if (arr[j] < pivot) {\\n                i++;\\n                int temp = arr[i];\\n                arr[i] = arr[j];\\n                arr[j] = temp;\\n            }\\n        }\\n        int temp = arr[i + 1];\\n        arr[i + 1] = arr[high];\\n        arr[high] = temp;\\\\n        return i + 1;\\n    }\\n\\n    public static void quickSort(int[] arr, int low, int high) {\\n        if (low < high) {\\n            int pi = partition(arr, low, high);\\n            quickSort(arr, low, pi - 1);\\n            quickSort(arr, pi + 1, high);\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] arr = { 38, 27, 43, 3, 9, 82, 10 };\\n        quickSort(arr, 0, arr.length - 1);\\n    }\\n}", "output": "3 9 10 27 38 43 82", "language": "Java"}	29
57	3	4	{"code": "def partition(arr, low, high):\\n    pivot = arr[high]\\n    i = low - 1\\n    for j in range(low, high):\\n        if arr[j] < pivot:\\n            i += 1\\n            arr[i], arr[j] = arr[j], arr[i]\\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\\n    return i + 1\\n\\ndef quick_sort(arr, low, high):\\n    if low < high:\\n        pi = partition(arr, low, high)\\n        quick_sort(arr, low, pi - 1)\\n        quick_sort(arr, pi + 1, high)\\n\\ndata = [38, 27, 43, 3, 9, 82, 10]\\nquick_sort(data, 0, len(data) - 1)", "output": "3 9 10 27 38 43 82", "language": "Python"}	30
75	4	4	{"code": "public class Main {\\n    public static int binarySearch(int[] arr, int target) {\\n        int left = 0, right = arr.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (arr[mid] == target) {\\n                return mid;\\n            } else if (arr[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    public static void main(String[] args) {\\n        int[] data = { 1, 2, 4, 7, 9 };\\n        System.out.println(\\"Found at index: \\" + binarySearch(data, 7));\\n    }\\n}", "output": "Found at index: 3", "language": "Java"}	10
76	4	4	{"code": "def binary_search(arr, target):\\n    left = 0\\n    right = len(arr) - 1\\n\\n    while left <= right:\\n        mid = (left + right) // 2\\n        if arr[mid] == target:\\n            return mid\\n        elif arr[mid] < target:\\n            left = mid + 1\\n        else:\\n            right = mid - 1\\n    return -1\\n\\ndata = [1, 2, 4, 7, 9]\\nprint(\\"Found at index: \\", binary_search(data, 7))", "output": "Found at index: 3", "language": "Python"}	11
\.


--
-- Data for Name: question; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.question (id, lesson_id, question_text, question_order) FROM stdin;
1	1	{"prompt": "What is an algorithm?"}	1
2	1	{"prompt": "Which field is most likely to use sorting or searching algorithms?"}	2
3	1	{"prompt": "What is a key characteristic of an algorithm?"}	3
4	1	{"prompt": "What does the finiteness of an algorithm mean?"}	4
5	1	{"prompt": "Which domain uses algorithms for analyzing large datasets and predicting outcomes?"}	5
7	2	{"prompt": "What does Big O notation describe in algorithm analysis?"}	1
8	2	{"prompt": "Which of these time complexities is the most efficient for very large input sizes?"}	2
9	2	{"prompt": "In the context of Big O notation, what does n usually represent?"}	3
11	2	{"prompt": "Which of the following Big O notations indicates exponential growth in time complexity?"}	5
13	3	{"prompt": "What is the main idea behind the Insertion Sort algorithm?"}	1
16	3	{"prompt": "Which algorithm is most efficient on small or nearly sorted arrays?"}	4
15	3	{"prompt": "In Quick Sort, what is the pivot element used for?"}	3
14	3	{"prompt": "Which sorting algorithm consistently has O(n log(n)) time complexity in all cases?"}	2
17	3	{"prompt": "What sorting algorithm is illustrated in the diagram?", "image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson3/merge_sort_example.png"}	5
18	3	{"prompt": "Which sorting algorithm divides the array into two parts and selects the smallest element for each position?"}	6
19	3	{"prompt": "What is the key operation in Bubble Sort?"}	7
20	4	{"prompt": "Which condition must be true for Binary Search to work?"}	1
21	4	{"prompt": "How does Linear Search find an item?"}	2
22	4	{"prompt": "What happens if Binary Search is applied to an unsorted array?"}	3
23	4	{"prompt": "Which algorithm uses divide-and-conquer strategy?"}	4
24	4	{"prompt": "Given the array shown in the picture, which algorithm is ideal to search for 86?", "image_path": "https://mvmmzqumvbjmmtcvrzxp.supabase.co/storage/v1/object/public/assets/lesson4/sorted_array.png"}	5
25	4	{"prompt": "Which of these is the best-case time complexity for Linear Search?"}	6
26	5	{"prompt": "What is Object-Oriented Programming?"}	1
27	5	{"prompt": "What does a class represent in OOP?"}	2
28	5	{"prompt": "What is an object in OOP?"}	3
29	5	{"prompt": "What is encapsulation?"}	4
30	5	{"prompt": "What is inheritance?"}	5
31	5	{"prompt": "What is abstraction?"}	6
32	5	{"prompt": "What is polymorphism?"}	7
10	2	{"code": "for (int i = 0; i < n; i++) {\\n    for (int j = 0; j < n; j++) {\\n        print(i + j);\\n    }\\n}", "prompt": "What is the time complexity of this function?"}	4
12	2	{"code": "int i = 1;\\nwhile (i < n) {\\n    print(i);\\n    i = i * 2;\\n}", "prompt": "What is the time complexity of this code?"}	6
33	5	{"code": "class Parent:\\n    def __init__(self, name):\\n        self.name = name\\n\\nclass Child(Parent):\\n    def __init__(self, age):\\n        self.age = age\\n\\nc = Child(10)\\nprint(c.name)", "prompt": "What is wrong in this code?"}	8
\.


--
-- Data for Name: role; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.role (id, name) FROM stdin;
1	admin
2	teacher
3	student
\.


--
-- Data for Name: user; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."user" (id, username, email, password_hash, first_name, last_name, image_path, role_id) FROM stdin;
2	aanic	P00v6bicOALcbOZsp0gYnSnFzF97AElHXqZlseh00Fg=	AQAAAAIAAYagAAAAEEkwXQbUvQtU7Ir5usIfbLe+tKkHh6vyRw0aDmuQP+wa6LW2Y+bYZ0D0CKcbDbyxGQ==	rlcBQd9fR4BBq04nNMmJvUmGZns46eq3mHOz2+BDXGg=	FaqkYwJDQcnBWuWyuf0cqgLf6SaXqM2f5Jx+sU+SYfk=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXb/weWjur1/VaHKlEWUc3wyhs6W3NxJelBjRK9dWIqU0lvbNSNz8uO4dvu54+cPkn/O+yGrHWrEARdOArcd2JWy	2
3	eemic	8hosNj8rJn1e1Y1cC+raJ0qL/+PgKoHJa3FrHOb77rc=	AQAAAAIAAYagAAAAEO1jgH5KZ/nZPipxcSUZj4HrpOxWSor7aD3wysSaemN0sWR6BtFAvLsfwUZ2ecyKiA==	7InNxd0Rkwi338H4BNMwtEtRGDaYLpHjZlem9y50vIA=	tzEULeT/yUNcjk105ZaQCuNS9sqnFBdItCHR6mbG0EI=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXb/weWjur1/VaHKlEWUc3wyhs6W3NxJelBjRK9dWIqU0lvbNSNz8uO4dvu54+cPkn/O+yGrHWrEARdOArcd2JWy	3
14	nnedic	F25U6hqV3664OqDwpFT6xFH8S1Ga9Rs67eYndtPwiJiWHMRVoI0kAaoCaQeeTShd	AQAAAAIAAYagAAAAEGt8A34lXqL+qCm7WNFRSGpPBezR9kL3qlK67dP2nhQqK3jDObDX3gqswtPjp04BYg==	NHIexHE2BwiwuSkIsjvgjE7OJmBfIDXXO8dIFgLss+8=	k61IA9POCLtVK3wz1TfYXrcAg1kg9GNM/syuoZjQrKc=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXaGDMCau9+KD/nMXU9FANu6tOSWpK0h9CQM9dRUyOoavhRi8TV8bft51zEeoz4qNHRRmrFXh2QPXtfAS8+BgGW+A1/U5g6t47XFxXFnwv6gsGFaYeEp9x0spIIPueM6bzo=	3
9	nnoic	SK/QVBK6kUML+IZTkPIzsYvUOR3hLsq3+jGKYer17Nk=	AQAAAAIAAYagAAAAEBFh69Um1Y/0mGp91QTZDu9VPyXYePX+kfEPO+6tQ/6GGzSMn2y/oOgTAYLzwS3RBg==	+zwIeNskkSYCrq5R/0QgRJRA+CBphCp3piLedx3ZcWg=	o2TcKUbMXFaCcs5mzgSYg6VQE43dyi/ejIRiPxi+dcY=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXalrXDaGaRWNXSNmrlDBSHuha/846h13DDM5OhcH/yjcER9437Ibz00EGJ0C6/8S/JN/dxRQnu3aqj6olNyWTSHOmjwgZ5eIKNbeFAt0ZN00myITl5sxz/bHgCnksPJsqQ=	1
13	llukic	Iea1Vod7mlJkMCiODGdsfaNrl5yLRNbJnDZ72x5DSKaLEJu/QabrtCi9PQ9FE8YG	AQAAAAIAAYagAAAAELz7A0t65CoNio+/6WZAnsGmlpaeBrtqjDNgchewp/hgkG9NPPWtEWJRBwubFbpqHw==	fYLjJI4K7Fwx5FKGSfp9HjyHt9B6AGKJ1CF9XyXLyYI=	1QRPK0IU3Arec4RZf5oT00h6z/b7NKXWGsOy8sKIYTw=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXbWdH3ypwyO82MsftxJU/ep+YyCuYZBx7msKaFf7CjnGvdSYuNaVVZ/lqOqjwAyPKsrFptQkP3jwggtBhI936fHZLqfcpi7PK0oJWG49ZxB/cyDUHK253rzQkGVPWbko/Y=	3
4	bbrunic	EyvPjdG2jhiEfHNeNWQtXHb/WcmnAOS9tnWLgB4KQp1+ub2eNJGhk7pcrisauZ3Q	AQAAAAIAAYagAAAAEDZkl5ulV+a4Yb6TzByMuYj/8Rd1RKmCcTwkJkd3gm9oXPuXCTfSESaTBin17wsEvg==	3fQQJhTkOPEgdif6dWpL2Eal4IBF4+8AXHYsq6UBXfg=	+DWKcQbP7h1gbUgxzONr7cfMtbqt8yjpHPLeFLxLyVk=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXa04sGSeyfX2MdFHN2Gw+LNpCQ26r3LaZtRpNhymaxN5y8aKT5oFXXZJ5SpbCAx8YPaAhxYLig/AeJcuF9SdYMs/rDzD/mxPAAirzzqdwvIF11ck1mCu/3WH9+5c4JBJ9w=	3
18	ttugic	M+BMGPItIqnuZdfHzyPvfutJvM43TKvNT3v6Yrt9wFhpm/uD+5650BJ8L9GXu8ow	AQAAAAIAAYagAAAAEAQTyr+luEBb1Kq2m0T3Fj3i+OuJnRRF15xJh6YVFwUDA6ZioLsRs2/8gLHnT1P1HQ==	TxORvB+Qy96E1otxm4a2TfSetQCN2fxRMBQu4URqJuc=	PaBR3LanGPS2kD6T1nCjR3THBMVYuUPcvntRLwyVbQ0=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXa8cNSRQmLYu83+Cq0hRGmh0wo7Hw5eMyQY6DXXYwrjUBphiXsWTQvPTCtAlqg9RVARb/RfgQblyElr/QxhEzekONf8KrsS77HykyTTWoXr4iJGzGOQKkK9xKj7DcZlTTg=	3
1	pperic	G7DTwwRV00MDS7FTr7vnlCupDh/Jr+3J1M7PLlHiq1Xy+AghFyi4qhloxUjSSdms	AQAAAAIAAYagAAAAEKL5hvuksHmn7cULY+RXnPvbFCXPvQCOsbm5o/LrvYQJGfg6Pg53+IjEplgQoGXOvw==	Y7yJ4kZBMqr82Xq6a950W2g8r8oz2KKqttwVJd0q0yE=	t6D9PZ6mqbJh7Kvckk/lPnI1GVktsosM8oJmz4Mjfrw=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXYfNcq9gkpBZdh2RIkz6LnIaKNCA9Dxb0wDlcRDDjTBoaWjVvX2uwEoQlztwZ3Q/2/T5IF4xt4d1cCx1zr4KKpMKi1X3b+lV2KVsh63J5hWXSi1FAyAdYVAEwYPvt84WRM=	1
12	ssaric	Sztpe/fzHyWb1zYMtTOlrsMZvv8pbgWy+xZF/jDGDuBhc3DtT+59Gc8WPmvQ8R3C	AQAAAAIAAYagAAAAEO/QEX43QdRUJk9i5bxtKid6duKg0cfot1NZ2ICsxHB8C0lZSjd5FWKzE0ROQIFKrA==	6I4CGOUdx/a3ZU0EGzNNJGE4RYF/6NEypRruNmV7icQ=	QsOtaz9DbuIwL9JC/KdZWb5udaMDh85JGbqEmsterx0=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXYkpcFIDomMLFexGkHh+SveEiq7tXkhSgIkkB6PHfj4apBqA+9ZMfToFn0BmXFoNP+Ny5KFS5kwckyLBbKm18qYZoeqxP6X+WlBygFVudV4CEN6j8dsDS0Dc/nBGLh3e2g=	2
5	ppijic	yh9y8VKQCPCyZQL/+yjvOxlfFDV3ya6HcpYo6w6Ub+vheiU5y+dG65VfRXnhDB+u	AQAAAAIAAYagAAAAED9rCyg4NMt+/aKs3QiALLVrG/anVQxXUCg4p++bQBEeznS3+hIYSYJtoYpZ+9gCww==	myU9jdqNoD8cSFRdNEbwPU6SZqOBXASotaT9uqjNvpc=	YDP6yGnAoiybcE+6GRHovzeU2974z9tPhjMtVPFPCJo=	69DaHIMwCAPmo79v33wwtx06vmVKFitAI6OPUlXpBhvuoWU4wNjJGgsQAtIxAXPu+KyExLZC20c0JwZ2YSZgBVE/2MMCpRI7vn7WARIKXXannZYIzyovQsq59VgTIt7l2/4pCoMBT6u1MdsCKJoYCZ7ufkpyt5mZemx3Fbnp9CgoDVLx035i75lntuXu819sKmtizq8iVFxy9IVMfKRW8Haf0fPBlWAcCxyZ62WgQtA=	3
\.


--
-- Data for Name: user_answer; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.user_answer (user_id, answer_id) FROM stdin;
18	2
18	10
18	13
18	17
18	19
18	26
18	31
18	6
18	8
18	22
18	29
18	61
18	65
18	66
18	68
18	55
18	59
18	36
18	39
18	41
18	45
18	49
18	53
18	48
13	35
13	39
13	42
13	44
13	48
13	51
13	54
\.


--
-- Data for Name: user_progress; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.user_progress (user_id, lesson_id, is_completed, score) FROM stdin;
18	1	t	100.00
18	2	t	83.33
18	4	t	66.67
18	3	f	14.29
13	3	t	57.14
\.


--
-- Name: answer_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.answer_id_seq', 94, true);


--
-- Name: content_type_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.content_type_id_seq', 4, true);


--
-- Name: lesson_content_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.lesson_content_id_seq', 96, true);


--
-- Name: lesson_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.lesson_id_seq', 5, true);


--
-- Name: question_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.question_id_seq', 33, true);


--
-- Name: role_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.role_id_seq', 3, true);


--
-- Name: user_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.user_id_seq', 20, true);


--
-- Name: answer answer_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.answer
    ADD CONSTRAINT answer_pkey PRIMARY KEY (id);


--
-- Name: content_type content_type_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.content_type
    ADD CONSTRAINT content_type_name_key UNIQUE (name);


--
-- Name: content_type content_type_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.content_type
    ADD CONSTRAINT content_type_pkey PRIMARY KEY (id);


--
-- Name: lesson_content lesson_content_lesson_id_content_order_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lesson_content
    ADD CONSTRAINT lesson_content_lesson_id_content_order_key UNIQUE (lesson_id, content_order);


--
-- Name: lesson_content lesson_content_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lesson_content
    ADD CONSTRAINT lesson_content_pkey PRIMARY KEY (id);


--
-- Name: lesson lesson_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lesson
    ADD CONSTRAINT lesson_pkey PRIMARY KEY (id);


--
-- Name: question question_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question
    ADD CONSTRAINT question_pkey PRIMARY KEY (id);


--
-- Name: role role_name_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role
    ADD CONSTRAINT role_name_key UNIQUE (name);


--
-- Name: role role_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.role
    ADD CONSTRAINT role_pkey PRIMARY KEY (id);


--
-- Name: user_answer user_answer_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_answer
    ADD CONSTRAINT user_answer_pkey PRIMARY KEY (user_id, answer_id);


--
-- Name: user user_email_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT user_email_key UNIQUE (email);


--
-- Name: user user_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT user_pkey PRIMARY KEY (id);


--
-- Name: user_progress user_progress_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_progress
    ADD CONSTRAINT user_progress_pkey PRIMARY KEY (user_id, lesson_id);


--
-- Name: user user_username_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT user_username_key UNIQUE (username);


--
-- Name: answer answer_question_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.answer
    ADD CONSTRAINT answer_question_id_fkey FOREIGN KEY (question_id) REFERENCES public.question(id) ON DELETE CASCADE;


--
-- Name: lesson_content lesson_content_content_type_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lesson_content
    ADD CONSTRAINT lesson_content_content_type_id_fkey FOREIGN KEY (content_type_id) REFERENCES public.content_type(id);


--
-- Name: lesson_content lesson_content_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.lesson_content
    ADD CONSTRAINT lesson_content_lesson_id_fkey FOREIGN KEY (lesson_id) REFERENCES public.lesson(id) ON DELETE CASCADE;


--
-- Name: question question_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.question
    ADD CONSTRAINT question_lesson_id_fkey FOREIGN KEY (lesson_id) REFERENCES public.lesson(id) ON DELETE CASCADE;


--
-- Name: user_answer user_answer_answer_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_answer
    ADD CONSTRAINT user_answer_answer_id_fkey FOREIGN KEY (answer_id) REFERENCES public.answer(id) ON DELETE CASCADE;


--
-- Name: user_answer user_answer_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_answer
    ADD CONSTRAINT user_answer_user_id_fkey FOREIGN KEY (user_id) REFERENCES public."user"(id) ON DELETE CASCADE;


--
-- Name: user_progress user_progress_lesson_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_progress
    ADD CONSTRAINT user_progress_lesson_id_fkey FOREIGN KEY (lesson_id) REFERENCES public.lesson(id) ON DELETE CASCADE;


--
-- Name: user_progress user_progress_user_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user_progress
    ADD CONSTRAINT user_progress_user_id_fkey FOREIGN KEY (user_id) REFERENCES public."user"(id) ON DELETE CASCADE;


--
-- Name: user user_role_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public."user"
    ADD CONSTRAINT user_role_id_fkey FOREIGN KEY (role_id) REFERENCES public.role(id);


--
-- PostgreSQL database dump complete
--

